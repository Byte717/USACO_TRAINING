1.Concept
- Know your Topic


2.Framework
- Ask questions on what might be able to solve this problem
- Try different things and don't get stuck on one idea

3.Form
-After you identify the topic, each topic can be broken into solving a couple different types of problems
- Find those "Forms" decide which one to use


4. Tactic
- Important ideas you need to know to solve a problem with a certain form and framework
- Important optimizations with implementation


-go back to past problems, 
---------------------------------------------------------------------------------------------------------------------

To Do List:
    - K Tree (Codeforces DP)
    - Project (DP)
    - Trainees (Codeforces Number theory)
    - Permutree (Codeforces)
    - irrigation (Range queries)
    - Best stock timne 3 (leetcode)
    - In a Mountain( Codeforces)
    - reversing game (Codeforces)
    - Number Game( DP)
    - Haircut (range queries)
    - Black cells(Codeforces)
    - Permutation COncatination (Codeforces)
    - Flipper (Codeforces)
    - Set Construction( Codeforces)
    - character block (Codeforces)
    - Imbalanced Arrays(Codeforces)
    - matchStick (Codeforces)
    - controllers(Codeforces)
    - dual v1(Codeforces)
    - kth equality(Codeforces)
    - Tourist Problem (CF)
    - Teleportation 
    - subset equality
    - teamwork(gold)
    - devu partition
    - Cow Poetry
--------------------------------------------------------------------------------------------------------------------
WITH EVERY PROBLEM,ONE NEW THING SHOULD BE ADDED TO YOUR KNOWLEDGE AS ONE OF THE MENTIONED BEFORE.


What I learned? Vampiric Powers 
- boolean arrays can be used to speed up the solution (tactic)
- Concept: Xor ranges
    - Intersections of ranges cancel out


What I learned: TenzingBalls
- instead of dp[i][j], you can break it into 2 separate arrays to speed up the time
- you can use inverse counting, dont count the answer, count n-ans

What I learned charBlock: 
-string hashing
-Queues can be used for queries that last for a time


WHat I Learned Flipper:
- Put bigger values first to maximize lexographical order

What I learned Contrast Value:
-For minimizing, considering greedily what can be removed
-Use a condition, like in dp

What i learned Array Painting:
- when counting a solution, think of how you can earn just 1 of something
- like in this problem, how can you use 1 coin to maximize numbers painted
- Segment the input into different pieces

What I learned Bracket Coloring:
- Greedy involves grouping your input

WHat I learned Freedom:
    - For divisibility problems, check the divisors of the number

What I learned Drawing Trees:
- find how to optimize problems with using base cases for what is visited
- like id represents 0 if the node was not added


WHat I learned Fibonacharsis:
- Try looking at solving brute force in reverse for a faster solution\

WHat I learned Phase Shift:
    - Lexographic implies greedy to take the smallest or largest character possible.
    
what I learned White Black Subtrees:
    - tree dp can be used to count solutions for subtrees.

WHat I learned Selfie:
- Binary search can be used to find values for queries.
- Difference EQUATION can be used to find if 2 equations intersect.

WHat I learned Interview:
    - Binary search can be used to search an interval

    
What I learned living sequence:
    - When dealing with number theory, break it into digits and look at them individually
    - base conversion is basically modding the number and dividing repeatedly.

What I learned Pull Luck:
    - the sum of numbers from 1 to 2*n is divisible by n; after that, the remainders repeat.
    - so check divisibility from 1 to 2*n

What I learned Redistributing gifts:
- kosaraju's algorithm
- SCCs can be used to solve graph problems.

what I learned Cow at large:
    - you can start bfs from multiple places

what I learned Fenced in Gold:(revisit)
    - try to make grid problems into graph problems
    
what I learned Berry Picking:
    - Think of setting upper bounds to minimize values in greedy

What I learned: 
    - in Greedy, think of approaches and take the best one!

What I learned QuizMaster:
    - in 2 pointer approach, keep moving the second pointer forward while you still can greedily
    - in number theory, store ther factors.

What I learned Lucky Sum:
    - in number theory, thoink of how you can store and construct the numbers with limitations
    - whenever something repeats, think of what interval it repeats on
    - use lower bound to speed up queries.

What I learned T-primes:
    - use the Sieve to find prime numbers for number theory

WHat I learned Xenia Divisors:
    - when constructing a solution, keep a track of what you have in a frequency array.

WHat I learned Chosing teams: 
    - just keep a count of what works individually and calculate from there in greedy
    - like the answer would be individual/3

What I learned Road Construction:
    - Star graphs, graphs that have a center

What I learned Tea tasting:
    - binary search can be used to speed up a solution that requires a second pointer
    - delta encoding, using cnt[i] as a prefix technique to count how many times the ith element has an operation done
    
What I learned Range update Point query:
    - binary search on sets using lower and upper bound
    - using sets to store active things that need to be editied.
        - like from l to r, only certain things need to be edited. 

what I learned routine Problem: revisit********
    - euclid's algorithm to find gcd

What I learned Sequences:
    - for number theory, write the pattern out brute force to see a pattern to speed up with

What I learned Dima line:
    -draw the base case out!!!!

What I learned Ciel flowers:
    - try to think of multiple greedy approaches and take the optimal one
    - think of a mathematical solution (like formulas) to speed things up

What I learned Max Absurdity: revisit *****
    - prefix sums can be used twice

What I learned Boredom: Revisit *****
    - dp can be used to find optimal solution and count the number of solutions.

what I learned Dima Equation:
    - sum of digits is very small, so iterate through that for number thoery to speed it up

what I learned tetrahedron:
    - DP: if memory is a problem, just keep the parts you need, dp[i-1]. then on the i'th iteration, calculate dp[i] and set dp[i-1] to dp[i] and repeat

what I learned Xor and OR:
    - think of the base cases. not everything has to be a complex algorithm
    
What I learned Desorting:
    - notice pattern in answer. it will be a common technique with a formula

what I learned sumProduct:
    - think of mathematical ideas. like multiplication and addition can be the quadratic formula
    - square roots can be found quick with binary search.

What I learned Closest Cow Wins:
    - when segmenting the input in greedy, think of the things you can do for the best solution in each segment
    - consider edge cases for an interval
    - two pointers/ sliding window can be limited to a length.

What I learned Spilting the Field: 
    - Min and Max Prefix sums, and suffix sums
    - Sorting points
    - Minimum enclosing area
    
What I learned Power of Points:
    - Prefix sums imply summation and vice versa.
    - intervals can be counted as their length
    - sort things, makes it easier.

what I learned Strong verticies: Revisit*****************
    - maniplulate the mathematical conditions provided.

What I learned Walkway:
    - think of base cases! AGAIN
    - boil the problem to math.

What I learned Pashmak's flowers:
    - n * (n-1)/2  is the formula to use for combinations when everything is the same

What I learned Caesar's legions: *** REVISIT *****
    - dp can be used to count states
    - add another dimention to dp when another state is needed
        - like, num footmen, num horseman, and current type

What i learned Xenia And Bits:
    - for queries, think segment trees.
    - segment trees can do other queries as well
    
what I learned Balanced Photo:
    - use 2 data structures for asynchronous queries.
    - BIT indexes can represent count arrays for inversion counting

WHat I learned Secret Cow Code:
    - think of minimal solutions for infinite sequences.

What I learned Why Did the cow cross the road gold:*********REVISIT******
    - shortest paths can also apply to grids
    
What I learned ColorStripe:
    - break into cases for certain kinds of input, like , n < 2, and n > 2;
    - think of the minimum change needed, this case, use just 3 characters;

What I learned Boots: REVISIT
    - dp can be used to figure out minimum, but just with trues and false
    - Think of states for dp,

What I learned Left Out: REVISIT
    - think of the base case of a problem that invalidates a specific conditon

What I learned Cow Steeple Chase 2:
    - for sweep line implementation:
        - Sort all points by x
        - iterate through them,
        - see if u can find them in the set
            - if u can, see if a condition holds true compared to the next and prev in the set
            - if u cant, remove it and see if u can see a condition hold true between next and prev
        - now calculate answer
    - when sorted, compare to value below and above
    
What I learned Moobuzz: Revisit
    - sequences tips:
        -either find repitition or reconstruct based on condition

No Time to Paint:
    - You can use prefix and suffix sums together to construct the answer

Cow Check List Gold: 
    - dp follow the struture
        if i > 1:

        if j > 1

        if i > 0 && j > 0:
    - dp also is based off of past numbers 
        dp[i] = dp[i-1] + some quantity

Lasers And mirrors:
    - map can be used to determine things on same x or y coordinate

Cow Navigation: 
    - multi source bfs can be useful for finding shortest paths from multiple sources

Why cross 1 Gold:   
    - bfs isnt restricted to up, down, left, and right. You can go diagonally, and break it into 2 parts

What I learned Informant:
    - When contrainst are big, look for repetition
        - like for example, when some operation is applied, when does it start to repeat?
    - Question every given operation/contraints
        - like why do we only apply a shift when a[i]= i? what happens when its not that.
What I learned Fine dining:
    - Consider adding another node to a graph to use as a reference point
    - for example, a node is needed to ensure that a path passes through certain nodes

WHat I learned shorcut:
    - its possible to find a possible shortest path using backtracking such as: 
    
    prev = the last node visited for the shortest path
    vector<ll> occ(n);
    for(int i = 0; i < n;i++){
        int cur = i;
        while(cur != INT32_MAX){
            occ[cur] += fields[i];
            cur = prev[cur];
        }
    }

what I learned Cow Operations:
    - look for relationships between tasks. for example,in this problem, i need to know that for make a substring just c, that c amount depends on o and w, and some combo of the 2.


What I learned powered addition:
- Filter an array based on conditions
    - eg. what is the minimum needed to make it sorted
    - its sorted when arr[i-1] < arr[i]
    - so add to a number when thats not met

WHat I learned Storage room:
    - bitwise operation narrows down numbers and 

What I learned THeo's nighmares:
    - try to look at suffix sums for a change


What I learned Q-sort:
    - in weird sorting algo problems, theres is always an observation of how the numbers move
        - Do elements go to the right faster? Do elements in a certain order make it impossible to sort?